import time
import os
import logging
import ccxt
import pandas as pd
import numpy as np
from telegram import Bot
from keep_alive import keep_alive

# ‚îÄ‚îÄ‚îÄ ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿàÿ± ⁄©Ÿà⁄Ü⁄© ‚îÄ‚îÄ‚îÄ
keep_alive()

# ‚îÄ‚îÄ‚îÄ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ±ÿ®ÿßÿ™ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ‚îÄ‚îÄ‚îÄ
TELEGRAM_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
bot = Bot(token=TELEGRAM_TOKEN)
bot.send_message(chat_id=CHAT_ID, text="‚úÖ ÿ±ÿ®ÿßÿ™ ÿßÿ≥ÿ™ÿßÿ±ÿ™ ÿ¥ÿØ Ÿà ÿ®Ÿá ÿØÿ±ÿ≥ÿ™€å ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™.")

# ‚îÄ‚îÄ‚îÄ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ŸÑÿß⁄Ø€åŸÜ⁄Ø ‚îÄ‚îÄ‚îÄ
logging.basicConfig(level=logging.INFO)

# ‚îÄ‚îÄ‚îÄ ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ÿµÿ±ÿßŸÅ€å ‚îÄ‚îÄ‚îÄ
exchange = ccxt.kucoin({"enableRateLimit": True})

# ‚îÄ‚îÄ‚îÄ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿß€å⁄Ü€åŸÖŸà⁄©Ÿà ‚îÄ‚îÄ‚îÄ
def ichimoku(df):
    high_prices = df['high']
    low_prices = df['low']
    nine_period_high = high_prices.rolling(window=9).max()
    nine_period_low = low_prices.rolling(window=9).min()
    df['Tenkan'] = (nine_period_high + nine_period_low) / 2
    period26_high = high_prices.rolling(window=26).max()
    period26_low = low_prices.rolling(window=26).min()
    df['Kijun'] = (period26_high + period26_low) / 2
    df['SenkouA'] = ((df['Tenkan'] + df['Kijun']) / 2).shift(26)
    period52_high = high_prices.rolling(window=52).max()
    period52_low = low_prices.rolling(window=52).min()
    df['SenkouB'] = ((period52_high + period52_low) / 2).shift(26)
    df['Chikou'] = df['close'].shift(-26)
    return df

# ‚îÄ‚îÄ‚îÄ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá StochRSI ‚îÄ‚îÄ‚îÄ
def calculate_stoch_rsi(df, period=14, smoothK=3, smoothD=3):
    delta = df['close'].diff()
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)
    avg_gain = pd.Series(gain).rolling(window=period).mean()
    avg_loss = pd.Series(loss).rolling(window=period).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    stoch_rsi = (rsi - rsi.rolling(period).min()) / (rsi.rolling(period).max() - rsi.rolling(period).min())
    df['StochRSI'] = stoch_rsi.rolling(smoothK).mean()
    return df

# ‚îÄ‚îÄ‚îÄ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ATR ‚îÄ‚îÄ‚îÄ
def calculate_atr(df, period=14):
    df['H-L'] = df['high'] - df['low']
    df['H-C'] = abs(df['high'] - df['close'].shift())
    df['L-C'] = abs(df['low'] - df['close'].shift())
    df['TR'] = df[['H-L', 'H-C', 'L-C']].max(axis=1)
    df['ATR'] = df['TR'].rolling(window=period).mean()
    return df
# ‚îÄ‚îÄ‚îÄ ÿ™ÿ¥ÿÆ€åÿµ ÿßŸÑ⁄ØŸàŸáÿß€å ⁄©ŸÜÿØŸÑ€å ‚îÄ‚îÄ‚îÄ
def detect_candlestick_patterns(df):
    patterns = []
    o, h, l, c = df.iloc[-2][['open', 'high', 'low', 'close']], df.iloc[-1][['open', 'high', 'low', 'close']], df.iloc[-1]['low'], df.iloc[-1]['close']

    if df['close'].iloc[-2] < df['open'].iloc[-2] and df['close'].iloc[-1] > df['open'].iloc[-1] and df['close'].iloc[-1] > df['open'].iloc[-2]:
        patterns.append('Bullish Engulfing')
    if df['close'].iloc[-2] > df['open'].iloc[-2] and df['close'].iloc[-1] < df['open'].iloc[-1] and df['close'].iloc[-1] < df['open'].iloc[-2]:
        patterns.append('Bearish Engulfing')
    if (df['close'].iloc[-1] > df['open'].iloc[-1] and 
        (df['low'].iloc[-1] < min(df['close'].iloc[-2], df['open'].iloc[-2])) and 
        (df['close'].iloc[-1] > (df['open'].iloc[-2] + df['close'].iloc[-2]) / 2)):
        patterns.append('Morning Star')
    if (df['close'].iloc[-1] < df['open'].iloc[-1] and 
        (df['high'].iloc[-1] > max(df['close'].iloc[-2], df['open'].iloc[-2])) and 
        (df['close'].iloc[-1] < (df['open'].iloc[-2] + df['close'].iloc[-2]) / 2)):
        patterns.append('Evening Star')
    return patterns

# ‚îÄ‚îÄ‚îÄ ÿ™ÿ¥ÿÆ€åÿµ ÿßŸàÿ±ÿØÿ± ÿ®ŸÑÿß⁄© ‚îÄ‚îÄ‚îÄ
def detect_order_block(df, period=20):
    order_blocks = []
    recent = df.tail(period)

    if recent['close'].iloc[-1] > recent['open'].iloc[-1] and recent['close'].max() > recent['close'].iloc[-2]:
        order_blocks.append("Bullish Order Block")
    if recent['close'].iloc[-1] < recent['open'].iloc[-1] and recent['close'].min() < recent['close'].iloc[-2]:
        order_blocks.append("Bearish Order Block")
    return order_blocks

# ‚îÄ‚îÄ‚îÄ ÿ®ÿ±ÿ±ÿ≥€å ŸÇÿØÿ±ÿ™ ÿ±ŸàŸÜÿØ ‚îÄ‚îÄ‚îÄ
def check_trend_strength(df):
    if df['close'].iloc[-1] > df['SenkouA'].iloc[-1] and df['close'].iloc[-1] > df['SenkouB'].iloc[-1]:
        if df['Tenkan'].iloc[-1] > df['Kijun'].iloc[-1]:
            return "strong_bullish"
        return "bullish"
    elif df['close'].iloc[-1] < df['SenkouA'].iloc[-1] and df['close'].iloc[-1] < df['SenkouB'].iloc[-1]:
        if df['Tenkan'].iloc[-1] < df['Kijun'].iloc[-1]:
            return "strong_bearish"
        return "bearish"
    return "neutral"

# ‚îÄ‚îÄ‚îÄ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≥ÿ∑Ÿàÿ≠ ŸÅ€åÿ®ŸàŸÜÿß⁄Ü€å ‚îÄ‚îÄ‚îÄ
def calculate_fibonacci(df, period=100):
    recent = df.tail(period)
    high = recent['high'].max()
    low = recent['low'].min()
    diff = high - low
    levels = {
        "0.236": high - diff * 0.236,
        "0.382": high - diff * 0.382,
        "0.5": high - diff * 0.5,
        "0.618": high - diff * 0.618,
        "0.786": high - diff * 0.786
    }
    return levels

# ‚îÄ‚îÄ‚îÄ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≥ÿß€åÿ≤ ŸæŸàÿ≤€åÿ¥ŸÜ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ATR Ÿà ÿ±€åÿ≥⁄© ÿØÿ±ÿµÿØ€å ‚îÄ‚îÄ‚îÄ
def position_size(entry, stop, risk=0.01, capital=1000):
    risk_amount = capital * risk
    trade_risk = abs(entry - stop)
    size = risk_amount / trade_risk if trade_risk != 0 else 0
    return size

# ‚îÄ‚îÄ‚îÄ ÿ™ÿ¥ÿÆ€åÿµ Ÿàÿß⁄Øÿ±ÿß€å€å (Bullish / Bearish Divergence) ‚îÄ‚îÄ‚îÄ
def detect_divergence(df, lookback=14):
    if len(df) < lookback+1:
        return None
    recent = df.tail(lookback)
    # ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±€åŸÜ ÿ≠ÿßŸÑÿ™: ŸÖŸÇÿß€åÿ≥Ÿá lows Ÿà highs ÿ®ÿß RSI
    lows = recent['close'].min()
    highs = recent['close'].max()
    rsi = recent['StochRSI'].iloc[-lookback:]
    # Bullish Divergence
    if (recent['close'].iloc[-1] < recent['close'].iloc[-2]) and (rsi.iloc[-1] > rsi.iloc[-2]):
        return 'bullish_divergence'
    # Bearish Divergence
    if (recent['close'].iloc[-1] > recent['close'].iloc[-2]) and (rsi.iloc[-1] < rsi.iloc[-2]):
        return 'bearish_divergence'
    return None

# ‚îÄ‚îÄ‚îÄ ⁄Øÿ±ŸÅÿ™ŸÜ OHLCV Ÿà ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ™ŸÖÿßŸÖ ÿßŸÜÿØ€å⁄©ÿßÿ™Ÿàÿ±Ÿáÿß ‚îÄ‚îÄ‚îÄ
def fetch_ohlcv(symbol="BTC/USDT", timeframe="1h", limit=200):
    df = pd.DataFrame(exchange.fetch_ohlcv(symbol, timeframe, limit=limit),
                      columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df = ichimoku(df)
    df = calculate_stoch_rsi(df)
    df = calculate_atr(df)
    return df
# ‚îÄ‚îÄ‚îÄ ÿ™ŸàŸÑ€åÿØ ÿ≥€å⁄ØŸÜÿßŸÑ Ÿà Ÿæ€åÿßŸÖ ⁄ÜŸÜÿØÿÆÿ∑€å ‚îÄ‚îÄ‚îÄ
def generate_signal(df, symbol=None):
    trend = check_trend_strength(df)
    patterns = detect_candlestick_patterns(df)
    order_blocks = detect_order_block(df)
    divergence = detect_divergence(df)
    fibonacci_levels = calculate_fibonacci(df)
    atr = df['ATR'].iloc[-1] if 'ATR' in df.columns else None
    entry = df['close'].iloc[-1]
    volume_mean = df['volume'].rolling(20).mean().iloc[-1] if len(df) >= 20 else df['volume'].mean()
    volume_check = df['volume'].iloc[-1] > volume_mean * 1.5
    stoch = df['StochRSI'].iloc[-1] if 'StochRSI' in df.columns else None
    stoch_buy = (stoch < 0.2) if (stoch is not None and not np.isnan(stoch)) else False
    stoch_sell = (stoch > 0.8) if (stoch is not None and not np.isnan(stoch)) else False
    atr_mean = df['ATR'].rolling(14).mean().iloc[-1] if 'ATR' in df.columns and len(df) >= 14 else None
    atr_check = False
    if (atr is not None) and (atr_mean is not None) and (not np.isnan(atr_mean)):
        atr_check = atr > atr_mean

    # ----- ÿ¥ÿ¥ ÿ¥ÿ±ÿ∑ ÿ®ÿ±ÿß€å BUY / SELL -----
    cond_trend_buy = ('bullish' in trend)
    cond_trend_sell = ('bearish' in trend)
    cond_pattern_buy = any(p in patterns for p in ['Bullish Engulfing', 'Morning Star', 'Three White Soldiers'])
    cond_pattern_sell = any(p in patterns for p in ['Bearish Engulfing', 'Evening Star', 'Three Black Crows'])
    cond_order_buy = any('Bullish' in ob for ob in order_blocks) if order_blocks else False
    cond_order_sell = any('Bearish' in ob for ob in order_blocks) if order_blocks else False
    cond_vol_stoch_buy = volume_check and stoch_buy
    cond_vol_stoch_sell = volume_check and stoch_sell
    cond_divergence_buy = divergence == 'bullish_divergence'
    cond_divergence_sell = divergence == 'bearish_divergence'

    buy_conditions = [cond_trend_buy, cond_pattern_buy, cond_order_buy, cond_vol_stoch_buy, atr_check, cond_divergence_buy]
    sell_conditions = [cond_trend_sell, cond_pattern_sell, cond_order_sell, cond_vol_stoch_sell, atr_check, cond_divergence_sell]

    buy_count = sum(1 for c in buy_conditions if c)
    sell_count = sum(1 for c in sell_conditions if c)

    if buy_count == 0 and sell_count == 0:
        return None

    if buy_count >= sell_count:
        side = "BUY"
        conditions_met = buy_count
        chosen_conditions = buy_conditions
        chosen_pattern_flag = cond_pattern_buy
        chosen_order_flag = cond_order_buy
        chosen_vol_stoch_flag = cond_vol_stoch_buy
        chosen_trend_flag = cond_trend_buy
        chosen_divergence_flag = cond_divergence_buy
    else:
        side = "SELL"
        conditions_met = sell_count
        chosen_conditions = sell_conditions
        chosen_pattern_flag = cond_pattern_sell
        chosen_order_flag = cond_order_sell
        chosen_vol_stoch_flag = cond_vol_stoch_sell
        chosen_trend_flag = cond_trend_sell
        chosen_divergence_flag = cond_divergence_sell

    if atr is None or np.isnan(atr):
        atr = (df['high'].iloc[-1] - df['low'].iloc[-1])
    if side == "BUY":
        stop = entry - atr * 1.5
        tp = entry + atr * 2
    else:
        stop = entry + atr * 1.5
        tp = entry - atr * 2

    size = position_size(entry, stop)

    stars = "‚≠ê" * int(conditions_met)
    lines = []
    if symbol:
        lines.append(f"üîî ÿ≥€å⁄ØŸÜÿßŸÑ ÿ®ÿ±ÿß€å {symbol}")
    lines.append(f"ŸÜŸàÿπ ÿ≥€å⁄ØŸÜÿßŸÑ: {side}")
    lines.append(f"ÿ™ÿπÿØÿßÿØ ÿ¥ÿ±Ÿàÿ∑ ÿ™ÿß€å€åÿØ ÿ¥ÿØŸá: {conditions_met}/6 {stars}")
    lines.append("")
    lines.append(f"1) ŸÅ€åŸÑÿ™ÿ± ÿ±ŸàŸÜÿØ: {trend} {'‚úÖ' if chosen_trend_flag else '‚ùå'}")
    lines.append(f"2) ÿßŸÑ⁄ØŸàŸáÿß€å ⁄©ŸÜÿØŸÑ€å: {patterns} {'‚úÖ' if chosen_pattern_flag else '‚ùå'}")
    lines.append(f"3) ÿßŸàÿ±ÿØÿ± ÿ®ŸÑÿß⁄©: {order_blocks} {'‚úÖ' if chosen_order_flag else '‚ùå'}")
    stoch_text = f"ÿ≠ÿ¨ŸÖ={df['volume'].iloc[-1]:.2f}, StochRSI={stoch:.3f}" if stoch is not None else f"ÿ≠ÿ¨ŸÖ={df['volume'].iloc[-1]:.2f}, StochRSI=N/A"
    lines.append(f"4) ÿ≠ÿ¨ŸÖ + StochRSI: {stoch_text} {'‚úÖ' if chosen_vol_stoch_flag else '‚ùå'}")
    atr_text = f"{atr:.6f}" if atr is not None else "N/A"
    lines.append(f"5) ATR check: {atr_text} {'‚úÖ' if atr_check else '‚ùå'}")
    lines.append(f"6) Ÿàÿß⁄Øÿ±ÿß€å€å: {divergence if divergence else 'N/A'} {'‚úÖ' if chosen_divergence_flag else '‚ùå'}")
    lines.append("")
    lines.append(f"Entry: {entry:.6f}")
    lines.append(f"Stop: {stop:.6f}")
    lines.append(f"TP: {tp:.6f}")
    lines.append(f"Size (units): {size:.6f}")
    lines.append("")
    lines.append("üìä ÿ≥ÿ∑Ÿàÿ≠ ŸÅ€åÿ®ŸàŸÜÿß⁄Ü€å:")
    for k, v in fibonacci_levels.items():
        lines.append(f"  {k}: {v:.6f}")
    message = "\n".join(lines)
    return message

# ‚îÄ‚îÄ‚îÄ ⁄Øÿ±ŸÅÿ™ŸÜ 80 ŸÖÿßÿ±⁄©ÿ™ ÿ®ÿ±ÿ™ÿ± ÿßÿ≤ KuCoin ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≠ÿ¨ŸÖ 24 ÿ≥ÿßÿπÿ™Ÿá (ŸÇÿßÿ®ŸÑ Ÿà€åÿ±ÿß€åÿ¥) ‚îÄ‚îÄ‚îÄ

def get_top_symbols(limit=80):
    """ÿ®ÿ±ÿ±ÿ≥€å €∏€∞ ÿ¨ŸÅÿ™ ŸÖÿπÿßŸÖŸÑÿßÿ™€å ÿ®ÿ±ÿ™ÿ± USDT ÿØÿ± KuCoin ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≠ÿ¨ŸÖ €≤€¥ ÿ≥ÿßÿπÿ™Ÿá.
    ÿß€åŸÜ ÿ™ÿßÿ®ÿπ ÿßÿ≤ exchange.fetch_tickers() ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜÿØ Ÿà ÿßŸÖŸÜ‚Äåÿ™ÿ±€åŸÜ ŸÖŸÇÿßÿØ€åÿ± ÿ≠ÿ¨ŸÖ ÿ±ÿß ÿßÿ≤ ŸÅ€åŸÑÿØŸáÿß€å ŸÖÿÆÿ™ŸÑŸÅ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖ€å‚Äå⁄©ŸÜÿØ.
    ÿß⁄Øÿ± ŸÖÿ¥⁄©ŸÑ ÿ±ÿÆ ÿØŸáÿØÿå ŸÑ€åÿ≥ÿ™ fallback ÿ¥ÿßŸÖŸÑ BTC/USDT ÿ±ÿß ÿ®ÿ±ŸÖ€å‚Äå⁄Øÿ±ÿØÿßŸÜÿØ.
    """
    try:
        tickers = exchange.fetch_tickers()
        data = []
        for sym, info in tickers.items():
            # ŸÅŸÇÿ∑ ÿ¨ŸÅÿ™‚ÄåŸáÿß€å USDT ÿ±ÿß ÿØÿ± ŸÜÿ∏ÿ± ŸÖ€å‚Äå⁄Ø€åÿ±€åŸÖ
            if not isinstance(sym, str) or not sym.endswith('/USDT'):
                continue
            vol = 0
            # ÿ≥ÿπ€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ ⁄ÜŸÜÿØ ŸÅ€åŸÑÿØ ŸÖŸÖ⁄©ŸÜ ÿ®ÿ±ÿß€å ÿ≠ÿ¨ŸÖ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åŸÖ
            try:
                if isinstance(info, dict):
                    vol = info.get('quoteVolume') or info.get('baseVolume') or 0
                    # ÿ®ÿπÿ∂€å Ÿæ€åÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å‚ÄåŸáÿß ÿ≠ÿ¨ŸÖ ÿ±ÿß ÿØÿ± ÿ≤€åÿ±⁄©ŸÑ€åÿØ 'info' ÿ∞ÿÆ€åÿ±Ÿá ŸÖ€å‚Äå⁄©ŸÜŸÜÿØ
                    if (not vol or vol == 0) and 'info' in info and isinstance(info['info'], dict):
                        vol = info['info'].get('quoteVolume') or info['info'].get('vol') or info['info'].get('baseVolume') or 0
            except Exception:
                vol = 0
            try:
                vol = float(vol)
            except Exception:
                vol = 0
            data.append((sym, vol))

        # ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≠ÿ¨ŸÖ 24 ÿ≥ÿßÿπÿ™Ÿá (ÿ®€åÿ¥ÿ™ÿ±€åŸÜ ÿßŸàŸÑ)
        data = sorted(data, key=lambda x: x[1], reverse=True)
        top = [s for s, v in data[:limit]]
        if not top:
            return ["BTC/USDT"]
        return top
    except Exception as e:
        logging.error(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ⁄Øÿ±ŸÅÿ™ŸÜ ŸÖÿßÿ±⁄©ÿ™‚ÄåŸáÿß ÿßÿ≤ KuCoin: {e}")
        return ["BTC/USDT"]


# ‚îÄ‚îÄ‚îÄ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ™ÿß€åŸÖ‚ÄåŸÅÿ±€åŸÖ‚ÄåŸáÿß (ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ÿ±ÿßÿ≠ÿ™ ‚Äî ÿß€åŸÜÿ¨ÿß ÿ™ÿ∫€å€åÿ± ÿ®ÿØ€åÿØ) ‚îÄ‚îÄ‚îÄ
TIMEFRAMES = ["15m", "1h", "4h", "1d"]
REQUIRED_CONFIRMATIONS = 2  # 1 €åÿπŸÜ€å ÿ®ÿß ÿ™ÿß€å€åÿØ 1 ÿ™ÿß€åŸÖ‚ÄåŸÅÿ±€åŸÖÿå 2 €åÿπŸÜ€å ŸÜ€åÿßÿ≤ ÿ®Ÿá 2 ÿ™ÿß€åŸÖ‚ÄåŸÅÿ±€åŸÖ ŸáŸÖ‚Äåÿ≥Ÿà

# ‚îÄ‚îÄ‚îÄ ÿ≠ŸÑŸÇŸá ÿßÿµŸÑ€å (ÿß⁄©ŸÜŸàŸÜ ÿ®ÿ±ÿß€å ŸÑ€åÿ≥ÿ™ 80 ŸÜŸÖÿßÿØ KuCoin ⁄©ÿßÿ± ŸÖ€å‚Äå⁄©ŸÜÿØ) ‚îÄ‚îÄ‚îÄ
def main():
    # ⁄Øÿ±ŸÅÿ™ŸÜ ŸÑ€åÿ≥ÿ™ ŸÜŸÖÿßÿØŸáÿß€å ÿ®ÿ±ÿ™ÿ± ÿßÿ≤ KuCoin
    symbols = get_top_symbols(limit=80)

    # ÿßÿ≤ ŸÖÿ™ÿ∫€åÿ±Ÿáÿß€å ŸÇÿßÿ®ŸÑ ÿ™ŸÜÿ∏€åŸÖ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    timeframes = TIMEFRAMES
    required_confirmations = REQUIRED_CONFIRMATIONS

    while True:
        try:
            for symbol in symbols:
                try:
                    signals = []
                    for tf in timeframes:
                        df = fetch_ohlcv(symbol, tf)
                        if df is None or df.empty:
                            continue
                        signal_text = generate_signal(df, symbol=f"{symbol} ({tf})")
                        if signal_text:
                            signals.append((tf, signal_text))

                    if signals:
                        buy_count = sum(1 for _tf, sig in signals if "ŸÜŸàÿπ ÿ≥€å⁄ØŸÜÿßŸÑ: BUY" in sig)
                        sell_count = sum(1 for _tf, sig in signals if "ŸÜŸàÿπ ÿ≥€å⁄ØŸÜÿßŸÑ: SELL" in sig)

                        final_signal = None
                        if buy_count >= required_confirmations and buy_count > sell_count:
                          final_signal = (
    f"‚úÖ ÿ≥€å⁄ØŸÜÿßŸÑ ŸÜŸáÿß€å€å BUY ÿ®ÿ±ÿß€å {symbol} "
    f"({buy_count}/{len(timeframes)} ÿ™ÿß€åŸÖ‚ÄåŸÅÿ±€åŸÖ)\n\n"
)

".join(f"[{tf}]
final_signal += "\n\n".join(
    f"[{tf}]\n{sig}" for tf, sig in signals if "ŸÜŸàÿπ ÿ≥€å⁄ØŸÜÿßŸÑ: BUY" in sig
)
"
                           final_signal += "\n\n".join(
    f"[{tf}]\n{sig}" for tf, sig in signals if "ŸÜŸàÿπ ÿ≥€å⁄ØŸÜÿßŸÑ: SELL" in sig
)

                        elif (buy_count >= required_confirmations or sell_count >= required_confirmations) and buy_count == sell_count:
                            final_signal = f"‚ö†Ô∏è ÿ™ÿß€åŸÖ‚ÄåŸÅÿ±€åŸÖ‚ÄåŸáÿß ÿ≥€å⁄ØŸÜÿßŸÑ ŸÖÿ™ŸÜÿßŸÇÿ∂ ŸÅÿ±ÿ≥ÿ™ÿßÿØŸÜÿØ ÿ®ÿ±ÿß€å {symbol}: BUY={buy_count}, SELL={sell_count}


                            final_signal += "

".join(f"[{tf}]
{sig}" for tf, sig in signals)

                        if final_signal:
                            logging.info(final_signal)
                            try:
                                bot.send_message(chat_id=CHAT_ID, text=final_signal)
                            except Exception as e:
                                logging.error(f"[Telegram Error] {e}")
                except Exception as e:
                    logging.error(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ {symbol}: {e}")

            # ÿ®ÿπÿØ ÿßÿ≤ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ⁄©ŸÑ ŸÑ€åÿ≥ÿ™ÿå €å⁄© ŸàŸÇŸÅŸá ⁄©ŸÑ€å
            time.sleep(60 * 5)

        except Exception as e:
            logging.error(f"‚ùå ÿÆÿ∑ÿß: {e}")
            time.sleep(60)


if __name__ == "__main__":
    main()
